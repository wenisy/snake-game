<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- æ·»åŠ è¿™äº›æ–°çš„ meta æ ‡ç­¾ -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- iOS ç‰¹å®šçš„ meta æ ‡ç­¾ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- æ·»åŠ åˆ°ä¸»å±å¹•æ—¶çš„æ ‡é¢˜ -->
    <meta name="apple-mobile-web-app-title" content="Snake Game">
    <title>Snake Battle Royale</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
            font-family: Arial, sans-serif;
            width: 100vw;
            height: 100vh;
        }

        #gameContainer {
            display: none;
            width: 100vw;
            height: 100vh;
        }

        #scoreboard {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
        }

        #scoreboard h3 {
            margin: 0 0 10px 0;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        #loginScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 1000;
        }

        input,
        button {
            margin: 10px;
            padding: 10px;
            font-size: 18px;
        }

        #gameCanvas {
            display: block;
        }

        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }

        .modal-content h2 {
            color: #ff4444;
            margin: 0 0 20px 0;
            font-size: 32px;
        }

        .score-info {
            margin: 20px 0;
            font-size: 20px;
        }

        .score-info p {
            margin: 10px 0;
        }

        #deathScreen button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #deathScreen button:hover {
            background: #45a049;
        }

        #scoreboard {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            min-width: 150px;
            max-height: 200px;
            overflow-y: auto;
        }


        #joystick-container,
        #boost-button {
            position: fixed !important;
            z-index: 1001 !important;
            /* ç¡®ä¿æ§åˆ¶å…ƒç´ å§‹ç»ˆåœ¨æœ€ä¸Šå±‚ */
        }

        /* æ·»åŠ ç§»åŠ¨è®¾å¤‡é€‚é…æ ·å¼ */
        @media (max-width: 768px) {
            #scoreboard {
                top: 10px;
                right: 50%;
                transform: translateX(50%);
                font-size: 10px;
                min-width: 120px;
                max-height: 150px;
                opacity: 0.8;
            }
        }
    </style>
</head>

<body>
    <div id="orientation-message">
        è¯·æ¨ªå±ä½¿ç”¨ä»¥è·å¾—æœ€ä½³æ¸¸æˆä½“éªŒ
    </div>
    <div id="loginScreen">
        <h1>Snake Battle Royale</h1>
        <input type="text" id="username" placeholder="Enter your username">
        <button onclick="joinGame()">Join Battle</button>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scoreboard"></div>
        <div id="countdownTimer" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); font-size: 48px; color: yellow; z-index: 200;"></div>
    </div>
    <div id="deathScreen" style="display: none;">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <div class="score-info">
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Final Rank: #<span id="finalRank">0</span></p>
            </div>
            <button onclick="retryGame()">Try Again</button>
        </div>
    </div>
    <!-- åœ¨bodyä¸­æ·»åŠ  -->
    <div id="joystick-container"
        style="position: fixed; bottom: 50px; left: 50px; width: 150px; height: 150px; background: rgba(255,255,255,0.2); border-radius: 50%; z-index: 1000;">
        <div id="joystick-knob"
            style="position: absolute; width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);">
        </div>
    </div>

    <!-- æ–°å¢åŠ é€ŸæŒ‰é’® -->
    <div id="boost-button"
        style="position: fixed; bottom: 50px; right: 50px; width: 80px; height: 80px; background: rgba(255,255,255,0.2); border-radius: 50%; z-index: 1000; display: flex; justify-content: center; align-items: center;">
        <div style="color: white; font-size: 12px;">BOOST</div>
    </div>

    <script>
        const BOARD_SIZE = 2552;
        const GRID_SIZE = 8;
        let gameState = {
            players: [],
            foods: []
        };

        class Renderer {
            constructor(canvas, gridSize) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.gridSize = gridSize;
                this.gridPattern = null;
                this.initGridPattern();
                this.invincibleGlowTime = 0;
            }

            initGridPattern() {
                const patternCanvas = document.createElement('canvas');
                const patternCtx = patternCanvas.getContext('2d');
                patternCanvas.width = this.gridSize * 20;
                patternCanvas.height = this.gridSize * 20;

                patternCtx.strokeStyle = '#222';
                patternCtx.lineWidth = 1;

                for (let x = 0; x < patternCanvas.width; x += this.gridSize) {
                    patternCtx.beginPath();
                    patternCtx.moveTo(x, 0);
                    patternCtx.lineTo(x, patternCanvas.height);
                    patternCtx.stroke();
                }
                for (let y = 0; y < patternCanvas.height; y += this.gridSize) {
                    patternCtx.beginPath();
                    patternCtx.moveTo(0, y);
                    patternCtx.lineTo(patternCanvas.width, y);
                    patternCtx.stroke();
                }

                this.gridPattern = this.ctx.createPattern(patternCanvas, 'repeat');
            }

            render(gameState, camera, viewportBounds) {
                const scale = window.gameInstance.scale;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();

                this.ctx.scale(scale, scale);

                this.ctx.translate(
                    -camera.x / scale,
                    -camera.y / scale
                );

                // å…ˆç»˜åˆ¶ç½‘æ ¼
                this.ctx.fillStyle = this.gridPattern;
                this.ctx.fillRect(
                    Math.floor(camera.x / this.gridSize) * this.gridSize,
                    Math.floor(camera.y / this.gridSize) * this.gridSize,
                    this.canvas.width / scale + this.gridSize * 2,
                    this.canvas.height / scale + this.gridSize * 2
                );

                // åœ¨é£Ÿç‰©å’Œè›‡ä¹‹å‰æ¸²æŸ“æ–¹å‘æŒ‡ç¤ºå™¨
                if (gameState.superFoodPosition) {
                    const superFood = Array.from(gameState.foods).find(f => f.isSuper);
                    if (superFood || gameState.superFoodCountdown !== null) {
                        this.renderSuperFoodIndicator(gameState.superFoodPosition, camera);
                    }
                }

                this.renderFoods(gameState.foods, viewportBounds);
                this.renderSnakes(gameState.players, viewportBounds);

                // æ¸²æŸ“å€’è®¡æ—¶ï¼ˆå¦‚æœæœ‰ï¼‰
                if (gameState.superFoodCountdown !== null) {
                    this.renderSuperFoodCountdown(gameState.superFoodCountdown);
                }

                this.ctx.restore();
            }

            isInViewport(obj, bounds) {
                const scale = window.gameInstance.scale;
                return obj.x >= bounds.left / scale &&
                    obj.x <= bounds.right / scale &&
                    obj.y >= bounds.top / scale &&
                    obj.y <= bounds.bottom / scale;
            }


            renderFoods(foods, bounds) {
                foods.forEach(food => {
                    if (this.isInViewport(food, bounds)) {
                        if (food.isSuper) {
                            // æ¸²æŸ“è¶…çº§é£Ÿç‰©ï¼ˆç†Šemojiï¼‰
                            this.ctx.font = `${this.gridSize * 5}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(
                                'ğŸ»',
                                food.x * this.gridSize + this.gridSize * 2.5,
                                food.y * this.gridSize + this.gridSize * 2.5
                            );
                        } else {
                            // æ¸²æŸ“æ™®é€šé£Ÿç‰©
                            this.ctx.fillStyle = '#FF0000';
                            this.ctx.beginPath();
                            this.ctx.arc(
                                food.x * this.gridSize + this.gridSize / 2,
                                food.y * this.gridSize + this.gridSize / 2,
                                this.gridSize / 2,
                                0,
                                Math.PI * 2
                            );
                            this.ctx.fill();
                        }
                    }
                });
            }

            renderSnakes(players, bounds) {
                this.invincibleGlowTime += 0.1;
                
                players.forEach(player => {
                    if (!player.alive) return;
                    if (!this.isSnakeInViewport(player.snake, bounds)) return;

                    // å¦‚æœè›‡å¤„äºæ— æ•ŒçŠ¶æ€ï¼Œæ·»åŠ é‡‘è‰²å…‰ç¯æ•ˆæœ
                    if (player.isInvincible) {
                        const glowIntensity = Math.sin(this.invincibleGlowTime) * 0.3 + 0.7; // 0.4 åˆ° 1.0 ä¹‹é—´é—ªçƒ
                        this.ctx.shadowColor = `rgba(255, 215, 0, ${glowIntensity})`;
                        this.ctx.shadowBlur = 30; // å¢åŠ å…‰æ™•æ•ˆæœ
                        this.ctx.strokeStyle = `rgba(255, 215, 0, ${glowIntensity})`;
                        this.ctx.lineWidth = 4; // åŠ ç²—å…‰ç¯
                        
                        // ä¸ºè›‡çš„æ¯ä¸ªéƒ¨åˆ†æ·»åŠ å…‰ç¯
                        player.snake.forEach(segment => {
                            // å¤–éƒ¨é‡‘è‰²å…‰ç¯
                            this.ctx.beginPath();
                            this.ctx.rect(
                                segment.x * this.gridSize - 4,
                                segment.y * this.gridSize - 4,
                                this.gridSize * 5 + 8,
                                this.gridSize * 5 + 8
                            );
                            this.ctx.stroke();

                            // æ·»åŠ æ˜Ÿæ˜Ÿæ•ˆæœ
                            const starSize = this.gridSize * 1.5;
                            this.ctx.fillStyle = `rgba(255, 255, 0, ${glowIntensity * 0.5})`;
                            this.ctx.beginPath();
                            const centerX = segment.x * this.gridSize + this.gridSize * 2.5;
                            const centerY = segment.y * this.gridSize + this.gridSize * 2.5;
                            for (let i = 0; i < 5; i++) {
                                const angle = (i * 2 * Math.PI / 5) + this.invincibleGlowTime;
                                const x = centerX + Math.cos(angle) * starSize;
                                const y = centerY + Math.sin(angle) * starSize;
                                if (i === 0) {
                                    this.ctx.moveTo(x, y);
                                } else {
                                    this.ctx.lineTo(x, y);
                                }
                            }
                            this.ctx.closePath();
                            this.ctx.fill();
                        });
                    }

                    // é‡ç½®é˜´å½±æ•ˆæœ
                    this.ctx.shadowColor = 'transparent';
                    this.ctx.shadowBlur = 0;

                    // ç»˜åˆ¶è›‡èº«
                    player.snake.forEach((segment, index) => {
                        if (index === 0) {
                            // ç»˜åˆ¶è›‡å¤´åº•è‰²
                            this.ctx.fillStyle = player.isInvincible ? 
                                `hsl(${(this.invincibleGlowTime * 50) % 360}, 100%, 50%)` : // å½©è™¹æ•ˆæœ
                                player.color;
                            this.ctx.fillRect(
                                segment.x * this.gridSize,
                                segment.y * this.gridSize,
                                this.gridSize * 5,
                                this.gridSize * 5
                            );

                            // è·å–ç§»åŠ¨æ–¹å‘
                            const direction = this.getSnakeDirection(player.snake);

                            // æ·»åŠ è›‡å¤´åˆ†éš”çº¿
                            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            
                            // æ ¹æ®ç§»åŠ¨æ–¹å‘ç¡®å®šåˆ†éš”çº¿ä½ç½®
                            if (direction.x > 0) { // å‘å³ç§»åŠ¨
                                this.ctx.moveTo(segment.x * this.gridSize + this.gridSize, segment.y * this.gridSize);
                                this.ctx.lineTo(segment.x * this.gridSize + this.gridSize, segment.y * this.gridSize + this.gridSize * 5);
                            } else if (direction.x < 0) { // å‘å·¦ç§»åŠ¨
                                this.ctx.moveTo(segment.x * this.gridSize + this.gridSize * 4, segment.y * this.gridSize);
                                this.ctx.lineTo(segment.x * this.gridSize + this.gridSize * 4, segment.y * this.gridSize + this.gridSize * 5);
                            } else if (direction.y > 0) { // å‘ä¸‹ç§»åŠ¨
                                this.ctx.moveTo(segment.x * this.gridSize, segment.y * this.gridSize + this.gridSize);
                                this.ctx.lineTo(segment.x * this.gridSize + this.gridSize * 5, segment.y * this.gridSize + this.gridSize);
                            } else { // å‘ä¸Šç§»åŠ¨
                                this.ctx.moveTo(segment.x * this.gridSize, segment.y * this.gridSize + this.gridSize * 4);
                                this.ctx.lineTo(segment.x * this.gridSize + this.gridSize * 5, segment.y * this.gridSize + this.gridSize * 4);
                            }
                            this.ctx.stroke();

                            // æ·»åŠ çœ¼ç›
                            this.ctx.fillStyle = 'white';
                            if (direction.x !== 0) { // æ°´å¹³ç§»åŠ¨
                                const eyeX = direction.x > 0 ? segment.x * this.gridSize + this.gridSize * 3.5 : segment.x * this.gridSize + this.gridSize * 1.5;
                                // ä¸Šçœ¼
                                this.ctx.beginPath();
                                this.ctx.arc(eyeX, segment.y * this.gridSize + this.gridSize * 1.5, this.gridSize * 0.8, 0, Math.PI * 2);
                                this.ctx.fill();
                                // ä¸‹çœ¼
                                this.ctx.beginPath();
                                this.ctx.arc(eyeX, segment.y * this.gridSize + this.gridSize * 3.5, this.gridSize * 0.8, 0, Math.PI * 2);
                                this.ctx.fill();
                            } else { // å‚ç›´ç§»åŠ¨
                                const eyeY = direction.y > 0 ? segment.y * this.gridSize + this.gridSize * 3.5 : segment.y * this.gridSize + this.gridSize * 1.5;
                                // å·¦çœ¼
                                this.ctx.beginPath();
                                this.ctx.arc(segment.x * this.gridSize + this.gridSize * 1.5, eyeY, this.gridSize * 0.8, 0, Math.PI * 2);
                                this.ctx.fill();
                                // å³çœ¼
                                this.ctx.beginPath();
                                this.ctx.arc(segment.x * this.gridSize + this.gridSize * 3.5, eyeY, this.gridSize * 0.8, 0, Math.PI * 2);
                                this.ctx.fill();
                            }

                            // æ·»åŠ ç³å­”
                            this.ctx.fillStyle = 'black';
                            if (direction.x !== 0) { // æ°´å¹³ç§»åŠ¨
                                const eyeX = direction.x > 0 ? segment.x * this.gridSize + this.gridSize * 3.7 : segment.x * this.gridSize + this.gridSize * 1.3;
                                // ä¸Šç³å­”
                                this.ctx.beginPath();
                                this.ctx.arc(eyeX, segment.y * this.gridSize + this.gridSize * 1.5, this.gridSize * 0.4, 0, Math.PI * 2);
                                this.ctx.fill();
                                // ä¸‹ç³å­”
                                this.ctx.beginPath();
                                this.ctx.arc(eyeX, segment.y * this.gridSize + this.gridSize * 3.5, this.gridSize * 0.4, 0, Math.PI * 2);
                                this.ctx.fill();
                            } else { // å‚ç›´ç§»åŠ¨
                                const eyeY = direction.y > 0 ? segment.y * this.gridSize + this.gridSize * 3.7 : segment.y * this.gridSize + this.gridSize * 1.3;
                                // å·¦ç³å­”
                                this.ctx.beginPath();
                                this.ctx.arc(segment.x * this.gridSize + this.gridSize * 1.5, eyeY, this.gridSize * 0.4, 0, Math.PI * 2);
                                this.ctx.fill();
                                // å³ç³å­”
                                this.ctx.beginPath();
                                this.ctx.arc(segment.x * this.gridSize + this.gridSize * 3.5, eyeY, this.gridSize * 0.4, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        } else {
                            // ç»˜åˆ¶è›‡èº«
                            this.ctx.fillStyle = player.color;
                            this.ctx.fillRect(
                                segment.x * this.gridSize,
                                segment.y * this.gridSize,
                                this.gridSize * 5,
                                this.gridSize * 5
                            );
                        }
                    });

                    // ç»˜åˆ¶åå­—
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = player.isInvincible ? 'bold 14px Arial' : '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(
                        `${player.username}${player.isInvincible ? ' ğŸ‘‘' : ''}`,
                        player.snake[0].x * this.gridSize + (this.gridSize * 5) / 2,
                        player.snake[0].y * this.gridSize - 5
                    );
                });
            }

            isInViewport(obj, bounds) {
                return obj.x >= bounds.left && obj.x <= bounds.right &&
                    obj.y >= bounds.top && obj.y <= bounds.bottom;
            }

            isSnakeInViewport(snake, bounds) {
                return snake.some(segment => this.isInViewport(segment, bounds));
            }

            // æ·»åŠ è·å–è›‡ç§»åŠ¨æ–¹å‘çš„è¾…åŠ©æ–¹æ³•
            getSnakeDirection(snake) {
                if (snake.length < 2) return { x: 1, y: 0 }; // é»˜è®¤å‘å³
                const head = snake[0];
                const neck = snake[1];
                return {
                    x: Math.sign(head.x - neck.x),
                    y: Math.sign(head.y - neck.y)
                };
            }

            // æ·»åŠ æ–°çš„æ–¹æ³•æ¥æ¸²æŸ“å€’è®¡æ—¶
            renderSuperFoodCountdown(countdown) {
                // ä¿å­˜å½“å‰è½¬æ¢çŠ¶æ€
                this.ctx.save();
                
                // é‡ç½®è½¬æ¢ä»¥åœ¨å±å¹•ä¸­å¿ƒç»˜åˆ¶
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // è®¾ç½®æ–‡æœ¬æ ·å¼
                this.ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // åœ¨å±å¹•ä¸­å¤®æ˜¾ç¤ºå€’è®¡æ—¶
                const text = `è¶…çº§é£Ÿç‰©å³å°†å‡ºç°: ${countdown}ç§’!`;
                this.ctx.fillText(text, this.canvas.width / 2, this.canvas.height / 3);
                
                // æ¢å¤è½¬æ¢çŠ¶æ€
                this.ctx.restore();
            }

            // ä¿®æ”¹æ–¹å‘æŒ‡ç¤ºå™¨æ¸²æŸ“æ–¹æ³•
            renderSuperFoodIndicator(superFoodPos, camera) {
                const currentPlayer = gameState.players.find(p => p.username === window.gameInstance.currentPlayer);
                if (!currentPlayer || !currentPlayer.snake.length) return;

                const head = currentPlayer.snake[0];
                const dx = superFoodPos.x - head.x;
                const dy = superFoodPos.y - head.y;
                const angle = Math.atan2(dy, dx);

                // åœ¨è›‡å¤´å‰æ–¹ç»˜åˆ¶ä¸€ç³»åˆ—ç®­å¤´
                const arrowSpacing = this.gridSize * 5; // ç®­å¤´é—´è·
                const numArrows = 3; // æ˜¾ç¤º3ä¸ªç®­å¤´
                const arrowSize = this.gridSize * 7; // ç®­å¤´å¤§å°
                const baseDistance = this.gridSize * 2; // ç¬¬ä¸€ä¸ªç®­å¤´è·ç¦»è›‡å¤´çš„è·ç¦»

                for (let i = 0; i < numArrows; i++) {
                    const distance = baseDistance + i * arrowSpacing;
                    const headCenterX = head.x * this.gridSize + this.gridSize * 2.5;
                    const headCenterY = head.y * this.gridSize + this.gridSize * 2.5;
                    const arrowX = headCenterX + Math.cos(angle) * distance;
                    const arrowY = headCenterY + Math.sin(angle) * distance;

                    this.ctx.save();
                    this.ctx.translate(arrowX, arrowY);
                    this.ctx.rotate(angle);

                    // ç»˜åˆ¶ç±»ä¼¼é©¬è·¯ç®­å¤´çš„å½¢çŠ¶
                    this.ctx.fillStyle = `rgba(255, 215, 0, ${0.15 - i * 0.03})`; // è¶Šè¿œè¶Šæ·¡
                    this.ctx.beginPath();
                    
                    // ç»˜åˆ¶ç®­å¤´å½¢çŠ¶ï¼ˆæ›´æ‰å¹³ï¼Œæ›´åƒé©¬è·¯ç®­å¤´ï¼‰
                    const width = arrowSize * 0.4;
                    const length = arrowSize * 0.8;
                    const headLength = arrowSize * 0.3;
                    
                    // ç®­å¤´ä¸»ä½“
                    this.ctx.moveTo(-length/2, -width/2);
                    this.ctx.lineTo(length/2 - headLength, -width/2);
                    this.ctx.lineTo(length/2 - headLength, -width);
                    this.ctx.lineTo(length/2, 0);
                    this.ctx.lineTo(length/2 - headLength, width);
                    this.ctx.lineTo(length/2 - headLength, width/2);
                    this.ctx.lineTo(-length/2, width/2);
                    this.ctx.closePath();
                    this.ctx.fill();

                    this.ctx.restore();
                }

                // åœ¨æœ€åä¸€ä¸ªç®­å¤´ä½ç½®æ˜¾ç¤ºè·ç¦»
                const lastArrowDistance = baseDistance + (numArrows - 1) * arrowSpacing;
                const textX = head.x * this.gridSize + this.gridSize * 2.5 + Math.cos(angle) * lastArrowDistance;
                const textY = head.y * this.gridSize + this.gridSize * 2.5 + Math.sin(angle) * lastArrowDistance;
                
                this.ctx.save();
                this.ctx.translate(textX, textY);
                this.ctx.rotate(angle);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.font = `${this.gridSize * 1.5}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const distance = Math.round(Math.sqrt(dx * dx + dy * dy));
                this.ctx.fillText(`${distance}`, 0, -this.gridSize * 2);
                this.ctx.restore();
            }
        }

        class ScoreManager {
            constructor(maxSize = 20) {
                this.scores = new Map();
                this.maxSize = maxSize;
                this.lastCleanup = Date.now();
                this.cleanupInterval = 10000; // 10ç§’æ¸…ç†ä¸€æ¬¡
            }

            update(players) {
                const now = Date.now();

                // æ¸…é™¤æ‰€æœ‰æ­»äº¡ç©å®¶çš„åˆ†æ•°
                for (const [username, data] of this.scores) {
                    const player = players.find(p => p.username === username);
                    if (!player || !player.alive) {
                        this.scores.delete(username);
                    }
                }

                // åªæ›´æ–°æ´»ç€çš„ç©å®¶åˆ†æ•°
                players.forEach(player => {
                    if (!player.alive) return;
                    const currentScore = player.snake.length;
                    this.scores.set(player.username, {
                        score: currentScore,
                        lastSeen: now,
                        color: player.color,
                        alive: true
                    });
                });

                // å®šæœŸæ¸…ç†
                if (now - this.lastCleanup > this.cleanupInterval) {
                    this.cleanup(now);
                    this.lastCleanup = now;
                }
            }

            cleanup(now) {
                // åˆ é™¤30ç§’æœªæ›´æ–°çš„åˆ†æ•°
                const timeoutThreshold = now - 30000;
                for (const [username, data] of this.scores) {
                    if (data.lastSeen < timeoutThreshold) {
                        this.scores.delete(username);
                    }
                }
            }

            getTopScores(limit = 10) {
                return Array.from(this.scores.entries())
                    .sort((a, b) => b[1].score - a[1].score)
                    .slice(0, limit);
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.scoreManager = new ScoreManager();
                this.scale = this.calculateScale();
                this.camera = { x: 0, y: 0 };
                this.currentPlayer = null;
                this.animationFrameId = null;
                this.lastFrameTime = performance.now();
                this.isPlayerDead = false;
                this.wsHandler = null;

                // ç¡®ä¿åœ¨è®¾ç½®scaleåå†åˆå§‹åŒ–renderer
                this.renderer = new Renderer(this.canvas, GRID_SIZE);
                this.initEventListeners();
            }

            calculateScale() {
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    return Math.min(window.innerWidth / 1024, 0.5);
                }
                return 1;
            }

            updateCamera() {
                const player = gameState.players.find(p => p.username === this.currentPlayer);
                if (player && player.snake.length > 0) {
                    const head = player.snake[0];
                    this.camera.x = head.x * GRID_SIZE - (this.canvas.width / this.scale) / 2;
                    this.camera.y = head.y * GRID_SIZE - (this.canvas.height / this.scale) / 2;
                }
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.scale = this.calculateScale();
                // é‡æ–°åˆå§‹åŒ–rendererçš„ç½‘æ ¼å›¾æ¡ˆ
                this.renderer.initGridPattern();
            }


            setWebSocketHandler(wsHandler) {  // æ·»åŠ è¿™ä¸ªæ–¹æ³•
                this.wsHandler = wsHandler;
            }

            initEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('unload', () => this.cleanup());
            }

            update() {
                this.updateCamera();
                this.scoreManager.update(gameState.players);

                const viewportBounds = {
                    left: this.camera.x / GRID_SIZE,
                    right: (this.camera.x + this.canvas.width / this.scale) / GRID_SIZE,
                    top: this.camera.y / GRID_SIZE,
                    bottom: (this.camera.y + this.canvas.height / this.scale) / GRID_SIZE
                };

                // ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„å‚æ•°è°ƒç”¨renderæ–¹æ³•
                this.renderer.render(gameState, this.camera, viewportBounds);

                const player = gameState.players.find(p => p.username === this.currentPlayer);
                if (player) {
                    if (player.alive === false && this.isPlayerDead === false) {
                        this.handlePlayerDeath(player);
                    } else if (player.alive === true) {
                        this.isPlayerDead = false;
                    }
                }

                this.updateScoreboard();

                // Update the countdown timer display if countdown is active
                if (gameState && gameState.countdown != null) {
                    document.getElementById('countdownTimer').innerHTML = `<div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 10px; color: #ff4444;">æ¸¸æˆå³å°†ç»“æŸ</div>
                        <div style="font-size: 48px; color: yellow;">${gameState.countdown}</div>
                    </div>`;
                } else if (gameState && gameState.superFoodCountdown != null) {
                    document.getElementById('countdownTimer').innerHTML = `<div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 10px; color: #ffd700;">è¶…çº§é£Ÿç‰©å³å°†å‡ºç°</div>
                        <div style="font-size: 48px; color: yellow;">${gameState.superFoodCountdown}</div>
                    </div>`;
                } else {
                    document.getElementById('countdownTimer').innerHTML = '';
                }

                const now = performance.now();
                const delta = now - this.lastFrameTime;
                this.fps = Math.round(1000 / delta);
                this.lastFrameTime = now;
            }

            handlePlayerDeath(player) {
                this.isPlayerDead = true;

                // è·å–æ‰€æœ‰ç©å®¶çš„åˆ†æ•°å¹¶æ’åº
                const allScores = gameState.players
                    .map(p => ({
                        username: p.username,
                        score: p.snake.length
                    }))
                    .sort((a, b) => b.score - a.score);

                // æ‰¾åˆ°å½“å‰ç©å®¶çš„æ’å
                let rank = 1;
                const playerScore = player.snake.length;
                for (const score of allScores) {
                    if (score.score > playerScore) rank++;
                }

                // æ›´æ–°æ­»äº¡å±å¹•ä¿¡æ¯
                document.getElementById('finalScore').textContent = playerScore;
                document.getElementById('finalRank').textContent = rank;
                document.getElementById('deathScreen').style.display = 'flex';
            }

            calculateRank(score) {
                // è·å–æ‰€æœ‰æ´»ç€çš„ç©å®¶çš„åˆ†æ•°
                const allScores = gameState.players
                    .map(p => p.snake.length)
                    .sort((a, b) => b - a);
                
                // æ‰¾åˆ°å½“å‰åˆ†æ•°çš„æ’å
                let rank = 1;
                for (const s of allScores) {
                    if (s > score) rank++;
                }
                return rank;
            }

            retry() {  // æ·»åŠ è¿™ä¸ªæ–¹æ³•
                const username = this.currentPlayer;
                document.getElementById('deathScreen').style.display = 'none';
                this.isPlayerDead = false;

                // æ·»åŠ ä¸€ä¸ªå°å»¶æ—¶
                setTimeout(() => {
                    if (this.wsHandler) {
                        this.wsHandler.joinGame(username);
                    }
                }, 100);
            }

            updateScoreboard() {
                const topScores = gameState.players
                    .sort((a, b) => b.snake.length - a.snake.length)
                    .slice(0, 10);

                let html = '<h3>Top 10 Players</h3>';

                topScores.forEach((player, index) => {
                    html += `
                        <div style="margin: 5px 0; ${player.alive ? '' : 'opacity: 0.5;'}">
                            <span style="color: gold">#${index + 1}</span> 
                            <span style="color: ${player.color}">${player.username}</span>: 
                            <span>${player.snake.length}</span>
                            ${player.alive ? '' : ' (Dead)'}
                        </div>
                    `;
                });

                document.getElementById('scoreboard').innerHTML = html;
            }


            gameLoop() {
                this.update();
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
            }

            cleanup() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
            }

            start() {
                this.resizeCanvas();
                this.gameLoop();

                // æ·»åŠ å…¨å±è¯·æ±‚
                const requestFullscreen = () => {
                    const element = document.documentElement;
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.mozRequestFullScreen) {
                        element.mozRequestFullScreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                };

                // ç›‘å¬è§¦æ‘¸äº‹ä»¶æ¥è§¦å‘å…¨å±
                document.addEventListener('touchstart', function () {
                    requestFullscreen();
                }, { once: true });
            }
        }

        class WebSocketHandler {
            constructor(game) {
                this.game = game;
                this.ws = new WebSocket(`ws://${window.location.host}`);
                this.currentDirection = { x: 1, y: 0 };
                this.setupEventListeners();
                this.setupJoystick();
                this.setupBoostButton();
                this.isBoostActive = false;
            }

            setupEventListeners() {
                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'gameState') {
                        gameState = data;
                    } else if (data.type === 'gameOver') {
                        handleGameOver(data.leaderboard);
                    } else if (data.type === 'gameReset') {
                        handleGameReset();
                    }
                };

                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            setupBoostButton() {
                const boostButton = document.getElementById('boost-button');

                // è§¦æ‘¸äº‹ä»¶
                const activateBoost = () => {
                    this.isBoostActive = true;
                    boostButton.style.background = 'rgba(255,255,255,0.4)';
                    this.ws.send(JSON.stringify({
                        type: 'boost',
                        boost: true
                    }));
                };

                const deactivateBoost = () => {
                    this.isBoostActive = false;
                    boostButton.style.background = 'rgba(255,255,255,0.2)';
                    this.ws.send(JSON.stringify({
                        type: 'boost',
                        boost: false
                    }));
                };

                // è§¦æ‘¸äº‹ä»¶
                boostButton.addEventListener('touchstart', activateBoost);
                boostButton.addEventListener('touchend', deactivateBoost);
                boostButton.addEventListener('touchcancel', deactivateBoost);

                // é¼ æ ‡äº‹ä»¶
                boostButton.addEventListener('mousedown', activateBoost);
                boostButton.addEventListener('mouseup', deactivateBoost);
                boostButton.addEventListener('mouseleave', deactivateBoost);

                // ç©ºæ ¼é”®æ§åˆ¶
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.repeat && !this.isBoostActive) {
                        activateBoost();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        deactivateBoost();
                    }
                });
            }

            setupJoystick() {
                const container = document.getElementById('joystick-container');
                const knob = document.getElementById('joystick-knob');
                let isDragging = false;
                let centerX, centerY;

                const updateJoystickPosition = (x, y) => {
                    const container = document.getElementById('joystick-container');
                    const rect = container.getBoundingClientRect();
                    centerX = rect.left + rect.width / 2;
                    centerY = rect.top + rect.height / 2;

                    const dx = x - centerX;
                    const dy = y - centerY;
                    const angle = Math.atan2(dy, dx);
                    const distance = Math.min(50, Math.sqrt(dx * dx + dy * dy));

                    const knobX = Math.cos(angle) * distance;
                    const knobY = Math.sin(angle) * distance;

                    knob.style.transform = `translate(${knobX}px, ${knobY}px)`;

                    // è®¡ç®—æ–¹å‘ (ç§»é™¤äº†åŠ é€Ÿç›¸å…³çš„ä»£ç )
                    if (distance > 10) {
                        const direction = {
                            x: Math.abs(Math.cos(angle)) > 0.5 ? Math.sign(Math.cos(angle)) : 0,
                            y: Math.abs(Math.sin(angle)) > 0.5 ? Math.sign(Math.sin(angle)) : 0
                        };

                        if (!this.isOppositeDirection(direction)) {
                            this.currentDirection = direction;
                            this.ws.send(JSON.stringify({
                                type: 'direction',
                                direction
                            }));
                        }
                    }
                };

                // è§¦æ‘¸äº‹ä»¶
                container.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                });

                container.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                    }
                });

                const resetJoystick = () => {
                    isDragging = false;
                    knob.style.transform = 'translate(-50%, -50%)';
                };

                container.addEventListener('touchend', resetJoystick);
                container.addEventListener('touchcancel', resetJoystick);

                // é¼ æ ‡äº‹ä»¶ï¼ˆå¯é€‰ï¼‰
                container.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    updateJoystickPosition(e.clientX, e.clientY);
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        updateJoystickPosition(e.clientX, e.clientY);
                    }
                });


                document.addEventListener('mouseup', resetJoystick);
            }

            handleKeyDown(e) {
                let direction = null;
                switch (e.key) {
                    case 'ArrowUp': direction = { x: 0, y: -1 }; break;
                    case 'ArrowDown': direction = { x: 0, y: 1 }; break;
                    case 'ArrowLeft': direction = { x: -1, y: 0 }; break;
                    case 'ArrowRight': direction = { x: 1, y: 0 }; break;
                }

                if (direction && !this.isOppositeDirection(direction)) {
                    this.currentDirection = direction;
                    this.ws.send(JSON.stringify({
                        type: 'direction',
                        direction
                    }));
                }
            }

            isOppositeDirection(newDir) {
                return (newDir.x === -this.currentDirection.x && newDir.y === 0) ||
                    (newDir.y === -this.currentDirection.y && newDir.x === 0);
            }

            joinGame(username) {
                this.ws.send(JSON.stringify({
                    type: 'join',
                    username
                }));
                this.game.currentPlayer = username;
                document.getElementById('deathScreen').style.display = 'none';
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            const game = new Game();
            const wsHandler = new WebSocketHandler(game);
            game.setWebSocketHandler(wsHandler);  // è®¾ç½® wsHandler
            window.gameInstance = game;

            // ç™»å½•å¤„ç†
            window.joinGame = () => {
                const username = document.getElementById('username').value.trim();
                if (username) {
                    document.getElementById('loginScreen').style.display = 'none';
                    document.getElementById('gameContainer').style.display = 'block';
                    wsHandler.joinGame(username);
                    game.start();
                }
            };

            // æ·»åŠ é‡è¯•å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸ
            window.retryGame = () => {
                if (window.gameInstance) {
                    window.gameInstance.retry();
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.getElementById('gameContainer').style.display = 'none';
                }
            };
        }

        // å¯åŠ¨æ¸¸æˆ
        initGame();

        // Add a function to handle game-over message
        function handleGameOver(leaderboard) {
            // Define emojis for top three
            const topEmojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
            let html = '<h2 style="font-size: 32px;">Game Over!</h2><h3 style="font-size: 24px;">Leaderboard</h3>';
            leaderboard.forEach((player, index) => {
                if (index < 3) {
                    html += `<div style="font-size: 20px; font-weight: bold; margin: 5px 0;">${topEmojis[index]} #${index + 1} ${player.username}: ${player.score}</div>`;
                } else {
                    html += `<div style="font-size: 16px; margin: 3px 0;">#${index + 1} ${player.username}: ${player.score}</div>`;
                }
            });
            html += '<button onclick="retryGame()" style="font-size: 18px; padding: 12px 30px;">Try Again</button>';
            document.getElementById('deathScreen').querySelector('.modal-content').innerHTML = html;
            document.getElementById('deathScreen').style.display = 'flex';
        }

        // æ·»åŠ å¤„ç†æ¸¸æˆé‡ç½®çš„å‡½æ•°
        function handleGameReset() {
            // æ˜¾ç¤ºç™»å½•ç•Œé¢
            document.getElementById('loginScreen').style.display = 'flex';
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('deathScreen').style.display = 'none';
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = {
                players: [],
                foods: []
            };
            
            // æ¸…ç©ºè®¡åˆ†æ¿
            document.getElementById('scoreboard').innerHTML = '';
            
            // æ¸…ç©ºå€’è®¡æ—¶æ˜¾ç¤º
            document.getElementById('countdownTimer').innerHTML = '';
            
            // é‡ç½®ç”¨æˆ·åè¾“å…¥æ¡†
            document.getElementById('username').value = '';
            
            console.log('Game has been reset');
        }
    </script>
</body>

</html>